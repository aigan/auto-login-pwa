<!DOCTYPE html>
<link rel="icon" href="/img/jonas-2016-300.jpg">
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="config.js"></script>
<script src="main.js"></script>
<body>
	<header>
		<section><span id="status">Loading</span></section>
		<spacer></spacer>
		<section class="logged-in"><button id="logout">Log out</button></section>
	</header>
	<main>
		<section class="logged-out">
			<section class="login-alternatives">
				<h1>You wanna log in?</h1>
				<button id="a_login" disabled>Log in</button>
				<button id="p_login" disabled><spinner></spinner>with Password</button>
				<button id="g_login" disabled><spinner></spinner>with Google</button>
				<button id="f_login" disabled>with Facebook</button>
			</section>
			<form class="login-password">
				<paper-input name="username" label="Name" type="text" autocomplete="username"></paper-input>
				<paper-input name="password" label="Password" type="password" autocomplete="current-password"></paper-input>
				<paper-button class="submit" raised>Login</paper-button>
				<input hidden="true" type="submit">
			</form>
		</section>
		<section class="logged-in">
			<p>It's a <span class="wow">brand</span> new world</p>
		</section>
		<section class="user-info">
			<button id="a_forget">Forget me</button> on this device
			<pre class="local"></pre>
			<pre class="password"></pre>
			<pre class="google"></pre>
			<pre class="facebook"></pre>
		</section>
	</main>
	
</body>
<style>
html {
	font-size: 16px; 
}
body {
	margin: 0;
	font-family: sans-serif;
}

header {
	display: flex;
	width: 100%;
	background: grey;
	min-height: 4em;
	flex-direction: row;
	box-sizing: border-box;
}

header, main {
	padding: 0.2em 1em;
}

spacer {
	flex-grow: 1;
}

.logged-in, form.login-password {
	display: none;
}

.wow {
	text-shadow: 0 0 .1em #FF0000;
}

header section {
	display: flex;
	flex-direction: column;
	justify-content: center;
}

header button {
	display: block;
}

button {
	font-size: 110%;
	padding: 0.4em 0.8em;
}

button:disabled {
	opacity: 0.2;
}

.login-password {
	text-align:center;
	max-width: 30em;
	margin: auto;
}

.login-password paper-input {
	text-align:left;
}

.login-password paper-button.submit {
	margin: 1.2em 0 0 0;
	width: 100%;
	color: white;
	background: #4059A9;
}

.user-info {
	margin-top: 1em;
}

spinner {
	content: "";
	display: inline-block;
	width: 0;
	height: 0;
	border: solid 0.5em;
	border-radius: 0.5em;
	border-color: #0099ff transparent #0099ff transparent;
	animation: spin 1s linear infinite;
}
@keyframes spin{
	0% {
		transform: rotate(0deg);
	}
	100% {
		transform: rotate(360deg);
	}
}

.login-alternatives button {
	position: relative;
}

.login-alternatives button spinner {
	position: absolute;
	display: none;
}
.login-alternatives button:disabled spinner {
	display: block;
}
.login-alternatives[cred_used]	button:disabled spinner {
	display: none;
}

</style>
<script>
"use strict";
log('index');

var alp = function(){

class Supplier {
	constructor(lib, origin) {
		this.lib = lib;
		this.origin = origin; // Federated identity providor
		this.label = null; // Will be set after cunstruction..
		this.ready = false;
		this.exec = null;
		this.promise = null;
		log("Constructing "+lib);
	}

	// reject handler somhow called twice here
	then(resolve_in, reject_in) {
		if(!this.promise) {
			var sup = this;
			this.promise = new Promise(function(resolve,reject){
				loadScriptAsync(sup.lib, function(){
//					log("Lib loaded. Calling sup.exec");
					sup.exec(resolve,reject);
				});
			});
		}
		this.promise.then(resolve_in, reject_in);
		return this;
	}
}

var c = { // Container for things to pass around
	u: null, // Current user
};
var s = // Supplier
{
	google: new Supplier('supplier/google.js',"https://accounts.google.com"),
	password: new Supplier('supplier/password.js'),
	facebook: {
		ready: false,
		origin: "https://www.facebook.com",
	},
	//		 test: new Supplier('supplier/test.js'),
};

var originIndex = {};
for( let sup in s ) {
	if(!s[sup].origin) continue;
	originIndex[s[sup].origin] = s[sup];
	s[sup].label = sup;
//	log("%s: %s", sup, s[sup].origin);
}

	// prefix for vendor components, taken form config,
	// excluding ending slash.
	var vendor = config.vendor || "bower_components";
	
class User {
	constructor(p) {
		if(!p) p = {};
		this.loggedin = p.loggedin || false;
		this.cred_id = p.cred_id;
		this.cred_used = p.cred_used;
		this.s = p.s || {};

		for( let sup in s ) {
			this.s[sup] = this.s[sup] || {};
		}
	}
}

////////////////////////////////////////////////////////////

function notifyStatus(msg) {
	fromId('status').innerHTML = msg;
}

function considerAutoLogin() {
	log("consider autoLogin");
	if( c.u.loggedin ) {
		notifyStatus("Welcome back");
		onLogin();
	} else if( c.u.cred_id && c.u.cred_used ) {
		// Identified but logged out. Respect that
		notifyStatus("");

		if(!!navigator.credentials) {
			log("GETTING navcred for future use");
			navigator.credentials.get({
				password: true,
				federated: {
					providers: Object.keys(originIndex),
				},
				unmediated: true,
			}).then( cred => {
				c.u.cred = cred;
				log("Got cred "+cred );
				if( cred )
					notifyStatus("Hello again");
				drawLoginWidget();
			});
		} else {
			// Load in suppliers
			s[c.u.cred_used].then( drawLoginWidget );
		}

	} else {
		a_login();
	}
}

function doLogout() {
	for( let sup of Object.keys(s) ) {
		if( s[sup].logout ) s[sup].logout();
	}

	if( !!navigator.credentials )
		navigator.credentials.requireUserMediation();
	
	notifyStatus("Logged out");
	c.u.loggedin = false;

	//Callbacks will remove data just after this update
	userUpdate();
	onLogout();
}

function doForget() {
	for( let sup of Object.keys(s) ) {
		if( s[sup].forget ) s[sup].forget();
	}

	if( !!navigator.credentials )
		navigator.credentials.requireUserMediation();
	
	notifyStatus("Logged out. Remeber to clear your device");
	c.u = new User();
	Lockr.rm('user');
	onLogout();
}

function a_login(by_click) {
	notifyStatus("Trying to log in "+(by_click?"by click":''));
	fromId('a_login').disabled = true;
	
	if(!navigator.credentials) {
		if( c.u.cred_used ) {
			// supplier loaded by considerAutoLogin()
				return s[c.u.cred_used].login();
		}
		
		notifyStatus("Your browser do not support credentials manager");
		c.u.cred_used = null;
		drawLoginWidget();
		return;
	}

	if( c.u.cred )
		return navcredLogin(c.u.cred, by_click);

	log("Getting navcred");
	navigator.credentials.get({
		password: true,
		federated: {
			providers: Object.keys(originIndex),
		},
//		unmediated: by_click?false:true,
	}).then( cred => {
		c.u.cred = cred;
		navcredLogin(cred, false);
	} );
}

function navcredLogin( cred, by_click ) {
	if( !cred ) {
		log("No cred");
		notifyStatus("No login credentials found");
		c.u.cred_used = null;
		userUpdate();
		drawLoginWidget();
		return;
	}

	if( cred.type == 'password' ) {
		s.password.then(_=>s.password.navcredLogin(cred, by_click));
	} else if( cred.type == 'federated' ) {
		log("Trying federated login");
		var sup = originIndex[cred.provider];
		if( sup && sup.navcredLogin ) {
			log("Direct call to navcredlogin");

			
			return sup.navcredLogin(cred, by_click);
		}
		else if( sup )
			return sup.then(_=>sup.navcredLogin(cred, by_click));

		log("Unhandled federated provider");
		log(cred.provider);
	}
}

function onLogin() {
	for(var item of queryAll('header .logged-in')) item.style.display = "flex";
	for(var item of queryAll('main .logged-in')) item.style.display = "block";
	for(var item of queryAll('.logged-out')) item.style.display = "none";
	query('.login-alternatives').style.display = 'block';
	query('.login-password').style.display = 'none';
}

function onLogout() {
	for(var item of queryAll('.logged-in')) item.style.display = "none";
	for(var item of queryAll('header .logged-out')) item.style.display = "flex";
	for(var item of queryAll('main .logged-out')) item.style.display = "block";

	//autoLogin();
	drawLoginWidget();
}

	function onGoogleAuthInitFailed(err){
		var spin = query('#g_login spinner');
		if( spin ) {
			var button = spin.parentNode;
			spin.remove();
			log(err);
			
			afterLoading('alp-warn', importAsync(["components/alp-warn.html"]), _ => {

				// The warning should be placed on the button, but will not
				// follow the button on line wrap. Should rather make this a
				// real property of the button,
				
				var alts = query(".login-alternatives");
				var details = document.createElement('details');
				details.innerHTML = `
<summary class="warn">&#x26a0;</summary>
<div class="info">
<p>Could not load Google login.</p>
<p>Try to <a target="external-help" href="http://www.howtogeek.com/241006/how-to-block-third-party-cookies-in-every-web-browser/">enable third-party cookies</a>.</p>
</div>`
				alts.insertBefore(details, button);
			});
		}
	}
	
function drawLoginWidget() {
	if( c.u.cred_used )
		query('.login-alternatives').setAttribute('cred_used',c.u.cred_used);
	fromId('a_login').disabled = !c.u.cred_used;
	if( !c.u.cred_used ) {
		fromId('p_login').disabled = !s.password.then().ready;
		fromId('g_login').disabled = !s.google.then(null,onGoogleAuthInitFailed).ready;
		fromId('f_login').disabled = !s.facebook.ready;
	} else {
		fromId('p_login').disabled = true;
		fromId('g_login').disabled = true;
		fromId('f_login').disabled = true;
	}
}

function userUpdate() {
	Lockr.set('user', {
		cred_id: c.u.cred_id,
		loggedin: c.u.loggedin,
		cred_used: c.u.cred_used,
		s: c.u.s,
	});
	onUserUpdated();
}

function onUserUpdated() {
	query('.user-info .local').innerHTML =
	`cred_id: ${c.u.cred_id}\ncred: ${c.u.cred_used}`;

	Object.keys(s).forEach( sup => {
//		log(sup);
		if( c.u.cred_used == sup )
			s[sup].then(_=> {
				if(s[sup].onUserUpdated)
					s[sup].onUserUpdated();
			});
	});
}

	// Workaround for bugs from race conditions in async component loading
	var polymerLoaded = false;
	function polymer(list,f) {
		if(!polymerLoaded){
			log("Polymer");
			let link = document.createElement('link');
			link.setAttribute('rel', 'import');
			link.setAttribute('href', vendor+"/polymer/polymer-micro.html");
			link.setAttribute('async', true);
			link.onload = function(){
				polymerLoaded = true;
				polymer(list,f);
			};
			document.body.appendChild(link);
			return;
		}

		var label = list[0].match(/([^\/]+)\.html/i)[1] || list[0];
		afterLoading(label, importAsync(list), f);
	}
	
	function onLoad() {
	c.u = new User(Lockr.get('user'));

	if( c.u ) {
		onUserUpdated();
	} else {
		c.u = new User();
		userUpdate();
	}
	
	fromId('logout').onclick = doLogout;

	fromId('p_login').onclick = function(){ s.password.login(true) };

	fromId('g_login').onclick = function(){ s.google.login(true) };
	
	fromId('a_login').onclick = function(){ a_login(true) };
	
	fromId('a_forget').onclick = doForget;

	considerAutoLogin();
}


	// Finish loading and setup
	loadScriptAsync(vendor+"/lockr/lockr.min.js", onLoad);

	return {
		s: s,
		c: c,
		drawLoginWidget: drawLoginWidget,
		onUserUpdated: onUserUpdated,
		notifyStatus: notifyStatus,
		userUpdate: userUpdate,
		onLogin: onLogin,
		polymer: polymer,
	}

}();
	
log("index init");
</script>
