<!DOCTYPE html>
<link rel="icon" href="/img/jonas-2016-300.jpg">
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="config.js"></script>
<script>try{eval("for(let i of document.querySelectorAll('body')){(i)=>i+1}")} catch(e){window.location.href="unsupported.html"}</script>
<script src="main.js"></script>
<body>
	<header>
		<section><span id="status">Loading</span></section>
		<spacer></spacer>
		<section class="logged-in"><button id="logout">Log out</button></section>
	</header>
	<main>
		<section class="logged-out">
			<section class="login-alternatives">
				<h1>You wanna log in?</h1>
				<button id="a_login" disabled>Log in</button>
				<button id="p_login" disabled><spinner></spinner>with Password</button>
				<button id="g_login" disabled><spinner></spinner>with Google</button>
				<button id="f_login" disabled>with Facebook</button>
			</section>
			<form class="login-password">
				<paper-input name="username" label="Name" type="text" autocomplete="username"></paper-input>
				<paper-input name="password" label="Password" type="password" autocomplete="current-password"></paper-input>
				<paper-button class="submit" raised>Login</paper-button>
				<input hidden="true" type="submit">
			</form>
		</section>
		<section class="logged-in">
			<p>It's a <span class="wow">brand</span> new world</p>
		</section>
		<section class="user-info">
			<button id="a_forget">Forget me</button> on this device
			<pre class="local"></pre>
			<pre class="password"></pre>
			<pre class="google"></pre>
			<pre class="facebook"></pre>
		</section>
	</main>
	
</body>
<style>
html {
	font-size: 16px; 
}
body {
	margin: 0;
	font-family: sans-serif;
}

header {
	display: flex;
	width: 100%;
	background: grey;
	min-height: 4em;
	flex-direction: row;
	box-sizing: border-box;
}

header, main {
	padding: 0.2em 1em;
}

spacer {
	flex-grow: 1;
}

.logged-in, form.login-password {
	display: none;
}

.wow {
	text-shadow: 0 0 .1em #FF0000;
}

header section {
	display: flex;
	flex-direction: column;
	justify-content: center;
}

header button {
	display: block;
}

button {
	font-size: 110%;
	padding: 0.4em 0.8em;
}

button:disabled {
	opacity: 0.2;
}

.login-password {
	text-align:center;
	max-width: 30em;
	margin: auto;
}

.login-password paper-input {
	text-align:left;
}

.login-password paper-button.submit {
	margin: 1.2em 0 0 0;
	width: 100%;
	color: white;
	background: #4059A9;
}

.user-info {
	margin-top: 1em;
}

spinner {
	content: "";
	display: inline-block;
	width: 0;
	height: 0;
	border: solid 0.5em;
	border-radius: 0.5em;
	border-color: #0099ff transparent #0099ff transparent;
	animation: spin 1s linear infinite;
}
@keyframes spin{
	0% {
		transform: rotate(0deg);
	}
	100% {
		transform: rotate(360deg);
	}
}

.login-alternatives button {
	position: relative;
}

.login-alternatives button spinner {
	position: absolute;
	display: none;
}
.login-alternatives button:disabled spinner {
	display: block;
}
.login-alternatives[cred_used]	button:disabled spinner {
	display: none;
}

</style>
<script>
"use strict";
log('index');

const alp = function(){
	const alpExport = {};
	
	class Supplier {
		constructor(lib, origin) {
			this.lib = lib;
			this.origin = origin; // Federated identity providor
			this.label = null; // Will be set after cunstruction..
			this.exec = null;
			this.promise = null;
			log("Constructing "+lib);

			mobx.extendObservable(this,{
				ready: false,
			});
			
		}

		// reject handler somhow called twice here
		then(resolve_in, reject_in) {
			if(!this.promise) {
				var sup = this;
				this.promise = new Promise(function(resolve,reject){
					scriptP(sup.lib).then(function(){
						//log("Lib loaded. Calling sup.exec");
						sup.exec(resolve,reject);
					});
				});
			}
			this.promise.then(resolve_in, reject_in);
			return this;
		}
	}

	var state; // Container for things to pass around
	const s = {}; // Supplier

	const originIndex = {};
	for( let sup in s ) {
		if(!s[sup].origin) continue;
		originIndex[s[sup].origin] = s[sup];
		s[sup].label = sup;
		//	log("%s: %s", sup, s[sup].origin);
	}

	// prefix for vendor components, taken form config,
	// excluding ending slash.
	const vendor = config.vendor || "bower_components";
	
	class User {
		constructor(p) {
			if(!p) p = {};
			const obj = {
				loggedin: p.loggedin || false,
				cred_id: p.cred_id, 
				cred_used: p.cred_used,
				s: p.s || {},
			};

			for( let sup in s ) {
				obj.s[sup] = obj.s[sup] || {loggedin:null};
			}

			mobx.extendObservable(this, obj);
		}

		
		static load() {
			state.u = new User(Lockr.get('user'));
			mobx.autorun(onUserUpdated);

			Object.keys(s).forEach( sup => {
				// log(sup);
				//if( state.u.cred_used == sup )
					s[sup].then(_=> {
						if(s[sup].onUserUpdated)
							mobx.autorun(s[sup].onUserUpdated); // autorun
					});
			});
			
			mobx.autorun(drawLoginWidget); // autorun
		}
	}

	////////////////////////////////////////////////////////////

	function notifyStatus(msg) {
		fromId('status').innerHTML = msg;
	}

	function considerAutoLogin() {
		log("consider autoLogin");
		if( state.u.loggedin ) {
			notifyStatus("Welcome back");
			onLogin();
		} else if( state.u.cred_id && state.u.cred_used ) {
			// Identified but logged out. Respect that
			notifyStatus("");

			if(!!navigator.credentials) {
				log("GETTING navcred for future use");
				navigator.credentials.get({
					password: true,
					federated: {
						providers: Object.keys(originIndex),
					},
					unmediated: true,
				}).then( cred => {
					state.u.cred = cred;
					log("Got cred "+cred );
					if( cred )
						notifyStatus("Hello again");
					//drawLoginWidget();
				});
			} else {
				// Load in suppliers
				//s[state.u.cred_used].then( drawLoginWidget );
				s[state.u.cred_used].then();
			}

		} else {
			a_login();
		}
	}

	function doLogout() {
		for( let sup of Object.keys(s) ) {
			if( s[sup].logout ) s[sup].logout();
		}

		if( !!navigator.credentials )
			navigator.credentials.requireUserMediation();
		
		notifyStatus("Logged out");
		state.u.loggedin = false;

		//Callbacks will remove data just after this update
		userUpdate();
		onLogout();
	}

	function doForget() {
		for( let sup of Object.keys(s) ) {
			if( s[sup].forget ) s[sup].forget();
		}

		if( !!navigator.credentials )
			navigator.credentials.requireUserMediation();
		
		notifyStatus("Logged out. Remeber to clear your device");
		state.u = new User();
		Lockr.rm('user');
		onLogout();
	}

	function a_login(by_click) {
		notifyStatus("Trying to log in "+(by_click?"by click":''));
		fromId('a_login').disabled = true;
		
		if(!navigator.credentials) {
			if( state.u.cred_used ) {
				// supplier loaded by considerAutoLogin()
					return s[state.u.cred_used].login();
			}
			
			notifyStatus("Your browser do not support credentials manager");
			state.u.cred_used = null;
			//drawLoginWidget();
			return;
		}

		if( state.u.cred )
			return navcredLogin(state.u.cred, by_click);

		log("Getting navcred");
		navigator.credentials.get({
			password: true,
			federated: {
				providers: Object.keys(originIndex),
			},
			//		unmediated: by_click?false:true,
		}).then( cred => {
			state.u.cred = cred;
			navcredLogin(cred, false);
		} );
	}

	function navcredLogin( cred, by_click ) {
		if( !cred ) {
			log("No cred");
			notifyStatus("No login credentials found");
			state.u.cred_used = null;
			userUpdate();
			//drawLoginWidget();
			return;
		}

		if( cred.type == 'password' ) {
			s.password.then(_=>s.password.navcredLogin(cred, by_click));
		} else if( cred.type == 'federated' ) {
			log("Trying federated login");
			var sup = originIndex[cred.provider];
			if( sup && sup.navcredLogin ) {
				log("Direct call to navcredlogin");

				
				return sup.navcredLogin(cred, by_click);
			}
			else if( sup )
				return sup.then(_=>sup.navcredLogin(cred, by_click));

			log("Unhandled federated provider");
			log(cred.provider);
		}
	}

	function onLogin() {
		state.view.page = '/';
	}

	function onLogout() {
		state.view.page = '/login';
	}

	function onGoogleAuthInitFailed(err){
		var spin = query('#g_login spinner');
		if( spin ) {
			var button = spin.parentNode;
			spin.remove();
			log(err);
			
			importP("components/alp-warn.html").then(_=>{
				// The warning should be placed on the button, but will not
				// follow the button on line wrap. Should rather make this a
				// real property of the button,
				
				var alts = query(".login-alternatives");
				var details = document.createElement('details');
				details.innerHTML = `
<summary class="warn">&#x26a0;</summary>
<div class="info">
<p>Could not load Google login.</p>
<p>Try to <a target="external-help" href="http://www.howtogeek.com/241006/how-to-block-third-party-cookies-in-every-web-browser/">enable third-party cookies</a>.</p>
</div>`
				alts.insertBefore(details, button);
			});
		}
	}
	
	function drawLoginWidget() {
		log("drawLoginWidget");

		const t_login_alts = query('.login-alternatives');
		const u = state.u;
		if( u.loggedin ) {
			for(var item of queryAll('header .logged-in')) item.style.display = "flex";
			for(var item of queryAll('main .logged-in')) item.style.display = "block";
			for(var item of queryAll('.logged-out')) item.style.display = "none";
			return;
		}

		for(let item of queryAll('.logged-in')) item.style.display = "none";
		for(let item of queryAll('header .logged-out')) item.style.display = "flex";
		for(let item of queryAll('main .logged-out')) item.style.display = "block";

		if( state.view.page != '/login' ) {
			t_login_alts.style.display = 'none';
			return;
		} 

		t_login_alts.style.display = 'block';

		
		if( state.u.cred_used )
			query('.login-alternatives').setAttribute('cred_used',state.u.cred_used);
		fromId('a_login').disabled = !state.u.cred_used;
		if( !state.u.cred_used ) {
			fromId('p_login').disabled = !s.password.then().ready;
			fromId('g_login').disabled = !s.google.then(null,onGoogleAuthInitFailed).ready;
			//fromId('f_login').disabled = !s.facebook.ready;
		} else {
			fromId('p_login').disabled = true;
			fromId('g_login').disabled = true;
			fromId('f_login').disabled = true;
		}
	}

	function userUpdate() {
		Lockr.set('user', {
			cred_id: state.u.cred_id,
			loggedin: state.u.loggedin,
			cred_used: state.u.cred_used,
			s: state.u.s,
		});
	}

	function onUserUpdated() {
		log("main onUserUpdated");
		query('.user-info .local').innerHTML =
		`cred_id: ${state.u.cred_id}\ncred: ${state.u.cred_used}`;
/*
		Object.keys(s).forEach( sup => {
			// log(sup);
			if( state.u.cred_used == sup )
				s[sup].then(_=> {
					if(s[sup].onUserUpdated)
						s[sup].onUserUpdated();
				});
		});
*/
	}

	// Workaround for bugs from race conditions in async component loading
	var polymerLoaded = false;
	function polymer(list,fn) { // Simpler to use callback here
		if(!polymerLoaded){
			log("Polymer");
			importP(vendor+"/polymer/polymer-micro.html").then(_=>{
				polymerLoaded = true;
				polymer(list,fn);
			});
			return;
		}
		var label = list[0].match(/([^\/]+)\.html/i)[1] || list[0];
		log("Importing "+label);
		return Promise.all(list.map((url)=>importP(url))).then(fn);
	}

	function onLoad() {
		alpExport.state = state = mobx.observable({
			u: null, // Current user
			view: {  // Current selection of what to view
				page: '/login',
				// other data goes here
			}
		});

		s.google =  new Supplier('supplier/google.js',"https://accounts.google.com");
		s.password = new Supplier('supplier/password.js');

		User.load();
		
		fromId('logout').onclick = doLogout;

		fromId('p_login').onclick = function(){ s.password.login(true) };

		fromId('g_login').onclick = function(){ s.google.login(true) };
		
		fromId('a_login').onclick = function(){ a_login(true) };
		
		fromId('a_forget').onclick = doForget;

		considerAutoLogin();
	}


	// Finish loading and setup
	Promise.all([
		scriptP(vendor+"/lockr/lockr.min.js"),
		scriptP(vendor+"/mobx/lib/mobx.umd.min.js"),
	]).then(onLoad);

	alpExport.s = s;
	//alpExport.state = state; // set onLoad
	//alpExport.drawLoginWidget = drawLoginWidget;
	//alpExport.onUserUpdated = onUserUpdated;
	alpExport.notifyStatus = notifyStatus;
	alpExport.userUpdate = userUpdate;
	alpExport.onLogin = onLogin;
	alpExport.polymer = polymer;

	return alpExport;

}();

log("index init");
</script>
